"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.synchronizeFile = exports.afterRunHook = exports.beforeRunHook = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const importExecutionConverter_1 = require("./conversion/importExecution/importExecutionConverter");
const importExecutionCucumberMultipartConverter_1 = require("./conversion/importExecutionCucumberMultipart/importExecutionCucumberMultipartConverter");
const logging_1 = require("./logging/logging");
const preprocessing_1 = require("./preprocessing/preprocessing");
const jiraIssueFetcher_1 = require("./repository/jira/fields/jiraIssueFetcher");
const util_1 = require("./types/util");
const dedent_1 = require("./util/dedent");
const errors_1 = require("./util/errors");
const help_1 = require("./util/help");
async function beforeRunHook(specs, options, clients) {
    // Cucumber upload requires additional test execution issue information.
    if (specs.some((spec) => options.cucumber &&
        options.xray.uploadResults &&
        spec.absolute.endsWith(options.cucumber.featureFileExtension))) {
        (0, logging_1.logInfo)("Fetching necessary Jira issue type information in preparation for Cucumber result uploads...");
        const issueDetails = await clients.jiraClient.getIssueTypes();
        if (!issueDetails) {
            throw new Error((0, dedent_1.dedent)(`
                    Jira issue type information could not be fetched.

                    Please make sure project ${options.jira.projectKey} exists at ${options.jira.url}

                    For more information, visit:
                    - ${help_1.HELP.plugin.configuration.jira.projectKey}
                    - ${help_1.HELP.plugin.configuration.jira.url}
                `));
        }
        options.jira.testExecutionIssueDetails = retrieveIssueTypeInformation(options.jira.testExecutionIssueType, issueDetails, options.jira.projectKey);
    }
}
exports.beforeRunHook = beforeRunHook;
function retrieveIssueTypeInformation(type, issueDetails, projectKey) {
    const details = issueDetails.filter((details) => details.name === type);
    if (details.length === 0) {
        throw new Error((0, dedent_1.dedent)(`
                Failed to retrieve issue type information for issue type: ${type}

                Make sure you have Xray installed.

                For more information, visit:
                - ${help_1.HELP.plugin.configuration.jira.testExecutionIssueType}
                - ${help_1.HELP.plugin.configuration.jira.testPlanIssueType}
            `));
    }
    else if (details.length > 1) {
        throw new Error((0, dedent_1.dedent)(`
                Found multiple issue types named: ${type}

                Make sure to only make a single one available in project ${projectKey}.

                For more information, visit:
                - ${help_1.HELP.plugin.configuration.jira.testExecutionIssueType}
                - ${help_1.HELP.plugin.configuration.jira.testPlanIssueType}
            `));
    }
    return details[0];
}
async function afterRunHook(results, options, clients) {
    const runResult = results;
    let issueKey = null;
    if ((0, preprocessing_1.containsNativeTest)(runResult, options.cucumber?.featureFileExtension)) {
        (0, logging_1.logInfo)("Uploading native Cypress test results...");
        issueKey = await uploadCypressResults(runResult, options, clients);
        if (options.jira.testExecutionIssueKey &&
            issueKey &&
            issueKey !== options.jira.testExecutionIssueKey) {
            (0, logging_1.logWarning)((0, dedent_1.dedent)(`
                    Cypress execution results were imported to test execution ${issueKey}, which is different from the configured one: ${options.jira.testExecutionIssueKey}

                    Make sure issue ${options.jira.testExecutionIssueKey} actually exists and is of type: ${options.jira.testExecutionIssueType}
                `));
        }
        else if (!options.jira.testExecutionIssueKey && issueKey) {
            // Prevents Cucumber results upload from creating yet another execution issue.
            options.jira.testExecutionIssueKey = issueKey;
        }
    }
    if ((0, preprocessing_1.containsCucumberTest)(runResult, options.cucumber?.featureFileExtension)) {
        (0, logging_1.logInfo)("Uploading Cucumber test results...");
        const cucumberIssueKey = await uploadCucumberResults(runResult, options, clients);
        if (options.jira.testExecutionIssueKey &&
            cucumberIssueKey &&
            cucumberIssueKey !== options.jira.testExecutionIssueKey) {
            (0, logging_1.logWarning)((0, dedent_1.dedent)(`
                    Cucumber execution results were imported to test execution ${cucumberIssueKey}, which is different from the configured one: ${options.jira.testExecutionIssueKey}

                    Make sure issue ${options.jira.testExecutionIssueKey} actually exists and is of type: ${options.jira.testExecutionIssueType}
                `));
        }
        if (options.jira.testExecutionIssueKey &&
            issueKey &&
            cucumberIssueKey &&
            cucumberIssueKey !== issueKey) {
            (0, logging_1.logWarning)((0, dedent_1.dedent)(`
                    Cucumber execution results were imported to a different test execution issue than the Cypress execution results.

                    This might be a bug, please report it at: https://github.com/Qytera-Gmbh/cypress-xray-plugin/issues
                `));
        }
        else if (!issueKey && cucumberIssueKey) {
            issueKey = cucumberIssueKey;
        }
    }
    if (issueKey === undefined) {
        (0, logging_1.logWarning)("Execution results import failed. Skipping remaining tasks");
        return;
    }
    else if (issueKey === null) {
        (0, logging_1.logWarning)("Execution results import was skipped. Skipping remaining tasks");
        return;
    }
    (0, logging_1.logSuccess)(`Uploaded test results to issue: ${issueKey} (${options.jira.url}/browse/${issueKey})`);
    if (options.jira.attachVideos) {
        await attachVideos(runResult, issueKey, clients.jiraClient);
    }
}
exports.afterRunHook = afterRunHook;
async function uploadCypressResults(runResult, options, clients) {
    const converter = new importExecutionConverter_1.ImportExecutionConverter(options, clients.kind === "cloud");
    try {
        const cypressExecution = await converter.toXrayJson(runResult);
        return await clients.xrayClient.importExecution(cypressExecution);
    }
    catch (error) {
        (0, logging_1.logError)((0, errors_1.errorMessage)(error));
    }
}
async function uploadCucumberResults(runResult, options, clients) {
    if (!options.cucumber?.preprocessor?.json.output) {
        throw new Error("Failed to upload Cucumber results: Cucumber preprocessor JSON report path not configured");
    }
    const results = JSON.parse(fs_1.default.readFileSync(options.cucumber.preprocessor.json.output, "utf-8"));
    const converter = new importExecutionCucumberMultipartConverter_1.ImportExecutionCucumberMultipartConverter(options, clients.kind === "cloud", clients.jiraRepository);
    const cucumberMultipart = await converter.convert(results, runResult);
    return await clients.xrayClient.importExecutionCucumberMultipart(cucumberMultipart.features, cucumberMultipart.info);
}
async function attachVideos(runResult, issueKey, jiraClient) {
    const videos = runResult.runs
        .map((result) => {
        return result.video;
    })
        .filter(util_1.nonNull);
    if (videos.length === 0) {
        (0, logging_1.logWarning)("No videos were uploaded: No videos have been captured");
    }
    else {
        await jiraClient.addAttachment(issueKey, ...videos);
    }
}
async function synchronizeFile(file, projectRoot, options, clients) {
    if (options.cucumber && file.filePath.endsWith(options.cucumber.featureFileExtension)) {
        try {
            const relativePath = path_1.default.relative(projectRoot, file.filePath);
            (0, logging_1.logInfo)(`Preprocessing feature file ${relativePath}...`);
            if (options.cucumber?.downloadFeatures) {
                // TODO: download feature file from Xray.
                throw new Error("feature not yet implemented");
            }
            if (options.cucumber?.uploadFeatures) {
                const issueData = (0, preprocessing_1.getCucumberIssueData)(file.filePath, options.jira.projectKey, clients.kind === "cloud");
                // Xray currently (almost) always overwrites issue summaries when importing feature
                // files to existing issues. Therefore, we manually need to backup and reset the
                // summary once the import is done.
                // See: https://docs.getxray.app/display/XRAY/Importing+Cucumber+Tests+-+REST
                // See: https://docs.getxray.app/display/XRAYCLOUD/Importing+Cucumber+Tests+-+REST+v2
                const issueKeys = [
                    ...issueData.tests.map((data) => data.key),
                    ...issueData.preconditions.map((data) => data.key),
                ];
                (0, logging_1.logDebug)((0, dedent_1.dedent)(`
                        Creating issue summary backups for issues:
                          ${issueKeys.join("\n")}
                    `));
                (0, logging_1.logInfo)("Importing feature file to Xray...");
                const testSummaries = await clients.jiraRepository.getSummaries(...issueKeys);
                const testLabels = await clients.jiraRepository.getLabels(...issueKeys);
                const wasImportSuccessful = await clients.xrayClient.importFeature(file.filePath, options.jira.projectKey);
                if (wasImportSuccessful) {
                    await resetSummaries(issueData, testSummaries, clients.jiraClient, clients.jiraRepository);
                    await resetLabels(issueData.tests, testLabels, clients.jiraClient, clients.jiraRepository);
                }
            }
        }
        catch (error) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Feature file invalid, skipping synchronization: ${file.filePath}

                    ${(0, errors_1.errorMessage)(error)}
                `));
        }
    }
    return file.filePath;
}
exports.synchronizeFile = synchronizeFile;
async function resetSummaries(issueData, testSummaries, jiraClient, jiraRepository) {
    const allIssues = [...issueData.tests, ...issueData.preconditions];
    for (let i = 0; i < allIssues.length; i++) {
        const issueKey = allIssues[i].key;
        const oldSummary = testSummaries[issueKey];
        const newSummary = allIssues[i].summary;
        if (!oldSummary) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Failed to reset issue summary of issue to its old summary: ${issueKey}
                    The issue's old summary could not be fetched, make sure to restore it manually if needed

                    Summary post sync: ${newSummary}
                `));
            continue;
        }
        if (oldSummary !== newSummary) {
            const summaryFieldId = await jiraRepository.getFieldId(jiraIssueFetcher_1.SupportedFields.SUMMARY);
            const fields = {};
            fields[summaryFieldId] = oldSummary;
            (0, logging_1.logDebug)((0, dedent_1.dedent)(`
                    Resetting issue summary of issue: ${issueKey}

                    Summary pre sync:  ${oldSummary}
                    Summary post sync: ${newSummary}
                `));
            if (!(await jiraClient.editIssue(issueKey, { fields: fields }))) {
                (0, logging_1.logError)((0, dedent_1.dedent)(`
                        Failed to reset issue summary of issue to its old summary: ${issueKey}

                        Summary pre sync:  ${oldSummary}
                        Summary post sync: ${newSummary}

                        Make sure to reset it manually if needed
                    `));
            }
        }
        else {
            (0, logging_1.logDebug)(`Issue summary is identical to scenario (outline) name already: ${issueKey} (${oldSummary})`);
        }
    }
}
async function resetLabels(issueData, testLabels, jiraClient, jiraRepository) {
    for (let i = 0; i < issueData.length; i++) {
        const issueKey = issueData[i].key;
        const oldLabels = testLabels[issueKey];
        const newLabels = issueData[i].tags;
        if (!oldLabels) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Failed to reset issue labels of issue to its old labels: ${issueKey}
                    The issue's old labels could not be fetched, make sure to restore them manually if needed

                    Labels post sync: ${newLabels}
                `));
            continue;
        }
        if (!newLabels.every((label) => oldLabels.includes(label))) {
            const labelFieldId = await jiraRepository.getFieldId(jiraIssueFetcher_1.SupportedFields.LABELS);
            const fields = {};
            fields[labelFieldId] = oldLabels;
            (0, logging_1.logDebug)((0, dedent_1.dedent)(`
                    Resetting issue labels of issue: ${issueKey}

                    Labels pre sync:  ${oldLabels}
                    Labels post sync: ${newLabels}
                `));
            if (!(await jiraClient.editIssue(issueKey, { fields: fields }))) {
                (0, logging_1.logError)((0, dedent_1.dedent)(`
                        Failed to reset issue labels of issue to its old labels: ${issueKey}

                        Labels pre sync:  ${oldLabels}
                        Labels post sync: ${newLabels}

                        Make sure to reset them manually if needed
                    `));
            }
        }
        else {
            (0, logging_1.logDebug)(`Issue labels are identical to scenario (outline) labels already: ${issueKey} (${oldLabels})`);
        }
    }
}
