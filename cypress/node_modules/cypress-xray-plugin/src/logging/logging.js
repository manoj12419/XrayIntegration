"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeErrorFile = exports.writeFile = exports.logDebug = exports.logWarning = exports.logSuccess = exports.logError = exports.logInfo = exports.initLogging = void 0;
const axios_1 = require("axios");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const errors_1 = require("../util/errors");
const INFO = "INFO";
const ERROR = "ERROR";
const SUCCESS = "SUCCESS";
const WARNING = "WARNING";
const DEBUG = "DEBUG";
const VARIANTS = [INFO, ERROR, SUCCESS, WARNING, DEBUG];
const MAX_PREFIX_LENGTH = Math.max(...VARIANTS.map((s) => s.length));
const PREFIXES = {
    info: prefix(INFO),
    error: prefix(ERROR),
    success: prefix(SUCCESS),
    warning: prefix(WARNING),
    debug: prefix(DEBUG),
};
let loggingOptions;
function initLogging(options) {
    loggingOptions = options;
}
exports.initLogging = initLogging;
function prefix(type) {
    return chalk_1.default.white(`│ Cypress Xray Plugin │ ${type.padEnd(MAX_PREFIX_LENGTH, " ")} │`);
}
const logInfo = (...text) => {
    log(text, PREFIXES.info, console.log, chalk_1.default.gray);
};
exports.logInfo = logInfo;
const logError = (...text) => {
    log(text, PREFIXES.error, console.error, chalk_1.default.red);
};
exports.logError = logError;
const logSuccess = (...text) => {
    log(text, PREFIXES.success, console.log, chalk_1.default.green);
};
exports.logSuccess = logSuccess;
const logWarning = (...text) => {
    log(text, PREFIXES.warning, console.log, chalk_1.default.yellow);
};
exports.logWarning = logWarning;
const logDebug = (...text) => {
    if (loggingOptions.debug) {
        log(text, PREFIXES.debug, console.log, chalk_1.default.cyan);
    }
};
exports.logDebug = logDebug;
function log(text, prefix, logger, colorizer) {
    const lines = text.join(" ").split("\n");
    lines.forEach((line, index) => {
        if (index === 0) {
            logger(`${prefix} ${colorizer(line)}`);
        }
        else {
            logger(`${prefix}   ${colorizer(line)}`);
        }
        // Pad multiline log messages with an extra new line to cleanly separate them from the
        // following line.
        if (index > 0 && index === lines.length - 1) {
            logger(prefix);
        }
    });
}
/**
 * Writes arbitrary data to a file under the log path configured in
 * {@link initLogging | `initLogging`}.
 *
 * @param data - the data to write
 * @param filename - the filename to use for the file
 */
function writeFile(data, filename) {
    const logDirectoryPath = path_1.default.resolve(loggingOptions.logDirectory);
    fs_1.default.mkdirSync(logDirectoryPath, { recursive: true });
    const filepath = path_1.default.resolve(logDirectoryPath, filename);
    fs_1.default.writeFileSync(filepath, JSON.stringify(data));
    return filepath;
}
exports.writeFile = writeFile;
/**
 * Writes an error to a file (e.g. HTTP response errors) under the log path configured in
 * {@link initLogging | `initLogging`}.
 *
 * @param error - the error
 * @param filename - the filename to use for the file
 */
function writeErrorFile(error, filename) {
    let errorFileName;
    let errorData;
    if ((0, errors_1.isLoggedError)(error)) {
        return;
    }
    if ((0, axios_1.isAxiosError)(error)) {
        errorFileName = `${filename}.json`;
        errorData = JSON.stringify({
            error: error.toJSON(),
            response: error.response?.data,
        });
    }
    else if (error instanceof Error) {
        errorFileName = `${filename}.json`;
        errorData = JSON.stringify({
            error: `${error.name}: ${error.message}`,
            stacktrace: error.stack,
        });
    }
    else {
        errorFileName = `${filename}.log`;
        errorData = JSON.stringify(error);
    }
    const logDirectoryPath = path_1.default.resolve(loggingOptions.logDirectory);
    fs_1.default.mkdirSync(logDirectoryPath, { recursive: true });
    errorFileName = path_1.default.resolve(logDirectoryPath, errorFileName);
    fs_1.default.writeFileSync(errorFileName, errorData);
    (0, exports.logError)(`Complete error logs have been written to: ${errorFileName}`);
}
exports.writeErrorFile = writeErrorFile;
