"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initClients = exports.initOpenSSLOptions = exports.initCucumberOptions = exports.initXrayOptions = exports.initPluginOptions = exports.initJiraOptions = exports.clearPluginContext = exports.setPluginContext = exports.getPluginContext = void 0;
const credentials_1 = require("./authentication/credentials");
const jiraClientCloud_1 = require("./client/jira/jiraClientCloud");
const jiraClientServer_1 = require("./client/jira/jiraClientServer");
const xrayClientCloud_1 = require("./client/xray/xrayClientCloud");
const xrayClientServer_1 = require("./client/xray/xrayClientServer");
const dependencies_1 = require("./dependencies");
const env_1 = require("./env");
const logging_1 = require("./logging/logging");
const jiraFieldRepository_1 = require("./repository/jira/fields/jiraFieldRepository");
const jiraIssueFetcher_1 = require("./repository/jira/fields/jiraIssueFetcher");
const jiraRepository_1 = require("./repository/jira/jiraRepository");
const dedent_1 = require("./util/dedent");
const help_1 = require("./util/help");
const parsing_1 = require("./util/parsing");
const ping_1 = require("./util/ping");
let context = undefined;
function getPluginContext() {
    return context;
}
exports.getPluginContext = getPluginContext;
function setPluginContext(newContext) {
    context = newContext;
}
exports.setPluginContext = setPluginContext;
function clearPluginContext() {
    context = undefined;
}
exports.clearPluginContext = clearPluginContext;
/**
 * Returns an {@link InternalJiraOptions | `InternalJiraOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing Jira options
 * @returns the constructed internal Jira options
 */
function initJiraOptions(env, options) {
    const projectKey = (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.projectKey, parsing_1.asString) ?? options.projectKey;
    if (!projectKey) {
        throw new Error("Plugin misconfiguration: Jira project key was not set");
    }
    const testExecutionIssueKey = (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueKey, parsing_1.asString) ?? options.testExecutionIssueKey;
    if (testExecutionIssueKey && !testExecutionIssueKey.startsWith(projectKey)) {
        throw new Error(`Plugin misconfiguration: test execution issue key ${testExecutionIssueKey} does not belong to project ${projectKey}`);
    }
    const testPlanIssueKey = (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testPlanIssueKey, parsing_1.asString) ?? options.testPlanIssueKey;
    if (testPlanIssueKey && !testPlanIssueKey.startsWith(projectKey)) {
        throw new Error(`Plugin misconfiguration: test plan issue key ${testPlanIssueKey} does not belong to project ${projectKey}`);
    }
    return {
        attachVideos: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.attachVideos, parsing_1.asBoolean) ?? options.attachVideos ?? false,
        fields: {
            description: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.description, parsing_1.asString) ??
                options.fields?.description,
            labels: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.labels, parsing_1.asString) ?? options.fields?.labels,
            summary: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.summary, parsing_1.asString) ?? options.fields?.summary,
            testEnvironments: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.testEnvironments, parsing_1.asString) ??
                options.fields?.testEnvironments,
            testPlan: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.testPlan, parsing_1.asString) ?? options.fields?.testPlan,
            testType: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.testType, parsing_1.asString) ?? options.fields?.testType,
        },
        projectKey: projectKey,
        testExecutionIssueDescription: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueDescription, parsing_1.asString) ??
            options.testExecutionIssueDescription,
        testExecutionIssueDetails: { subtask: false },
        testExecutionIssueKey: testExecutionIssueKey,
        testExecutionIssueSummary: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueSummary, parsing_1.asString) ??
            options.testExecutionIssueSummary,
        testExecutionIssueType: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueType, parsing_1.asString) ??
            options.testExecutionIssueType ??
            "Test Execution",
        testPlanIssueKey: testPlanIssueKey,
        testPlanIssueType: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testPlanIssueType, parsing_1.asString) ??
            options.testPlanIssueType ??
            "Test Plan",
        url: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.url, parsing_1.asString) ?? options.url,
    };
}
exports.initJiraOptions = initJiraOptions;
/**
 * Returns an {@link InternalPluginOptions | `InternalPluginOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing plugin options
 * @returns the constructed internal plugin options
 */
function initPluginOptions(env, options) {
    return {
        debug: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.debug, parsing_1.asBoolean) ?? options?.debug ?? false,
        enabled: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.enabled, parsing_1.asBoolean) ?? options?.enabled ?? true,
        logDirectory: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.logDirectory, parsing_1.asString) ?? options?.logDirectory ?? "logs",
        normalizeScreenshotNames: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.normalizeScreenshotNames, parsing_1.asBoolean) ??
            options?.normalizeScreenshotNames ??
            false,
    };
}
exports.initPluginOptions = initPluginOptions;
/**
 * Returns an {@link InternalXrayOptions | `InternalXrayOptions`} instance based on parsed environment
 * variables and a provided options object. Environment variables will take precedence over the
 * options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing Xray options
 * @returns the constructed internal Xray options
 */
function initXrayOptions(env, options) {
    return {
        status: {
            failed: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.failed, parsing_1.asString) ?? options?.status?.failed,
            passed: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.passed, parsing_1.asString) ?? options?.status?.passed,
            pending: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.pending, parsing_1.asString) ?? options?.status?.pending,
            skipped: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.skipped, parsing_1.asString) ?? options?.status?.skipped,
        },
        testEnvironments: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.testEnvironments, parsing_1.asArrayOfStrings) ??
            options?.testEnvironments,
        uploadResults: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.uploadResults, parsing_1.asBoolean) ?? options?.uploadResults ?? true,
        uploadScreenshots: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.uploadScreenshots, parsing_1.asBoolean) ??
            options?.uploadScreenshots ??
            true,
    };
}
exports.initXrayOptions = initXrayOptions;
/**
 * Returns an {@link InternalCucumberOptions | `InternalCucumberOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing Cucumber options
 * @returns the constructed internal Cucumber options
 */
async function initCucumberOptions(config, options) {
    // Check if the user has chosen to upload Cucumber results, too.
    const featureFileExtension = (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.featureFileExtension, parsing_1.asString) ??
        options?.featureFileExtension;
    // If the user has chosen to do so, we need to make sure they configured the Cucumber
    // preprocessor JSON report as well. Otherwise, results upload will not work.
    if (featureFileExtension) {
        let preprocessor;
        try {
            preprocessor = await (0, dependencies_1.importOptionalDependency)("@badeball/cypress-cucumber-preprocessor");
        }
        catch (error) {
            throw new Error((0, dedent_1.dedent)(`
                    Plugin dependency misconfigured: @badeball/cypress-cucumber-preprocessor

                    ${error}

                    The plugin depends on the package and should automatically download it during installation, but might have failed to do so because of conflicting Node versions

                    Make sure to install the package manually using: npm install @badeball/cypress-cucumber-preprocessor --save-dev
                `));
        }
        (0, logging_1.logDebug)(`Successfully resolved configuration of @badeball/cypress-cucumber-preprocessor package`);
        const preprocessorConfiguration = await preprocessor.resolvePreprocessorConfiguration(config, config.env, "/");
        if (!preprocessorConfiguration.json.enabled) {
            throw new Error((0, dedent_1.dedent)(`
                        Plugin misconfiguration: Cucumber preprocessor JSON report disabled

                        Make sure to enable the JSON report as described in https://github.com/badeball/cypress-cucumber-preprocessor/blob/master/docs/json-report.md
                    `));
        }
        if (!preprocessorConfiguration.json.output) {
            throw new Error((0, dedent_1.dedent)(`
                        Plugin misconfiguration: Cucumber preprocessor JSON report path was not set

                        Make sure to configure the JSON report path as described in https://github.com/badeball/cypress-cucumber-preprocessor/blob/master/docs/json-report.md
                    `));
        }
        return {
            downloadFeatures: (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.downloadFeatures, parsing_1.asBoolean) ??
                options?.downloadFeatures ??
                false,
            featureFileExtension: featureFileExtension,
            preprocessor: preprocessorConfiguration,
            uploadFeatures: (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.uploadFeatures, parsing_1.asBoolean) ??
                options?.uploadFeatures ??
                false,
        };
    }
    return undefined;
}
exports.initCucumberOptions = initCucumberOptions;
/**
 * Returns an {@link InternalOpenSSLOptions | `InternalOpenSSLOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing OpenSSL options
 * @returns the constructed internal OpenSSL options
 */
function initOpenSSLOptions(env, options) {
    return {
        rootCAPath: (0, parsing_1.parse)(env, env_1.ENV_NAMES.openSSL.rootCAPath, parsing_1.asString) ?? options?.rootCAPath,
        secureOptions: (0, parsing_1.parse)(env, env_1.ENV_NAMES.openSSL.secureOptions, parsing_1.asInt) ?? options?.secureOptions,
    };
}
exports.initOpenSSLOptions = initOpenSSLOptions;
async function initClients(jiraOptions, env) {
    if (!jiraOptions.url) {
        throw new Error((0, dedent_1.dedent)(`
                Failed to configure Jira client: no Jira URL was provided
                Make sure Jira was configured correctly: ${help_1.HELP.plugin.configuration.authentication.jira.root}
            `));
    }
    if (env_1.ENV_NAMES.authentication.jira.username in env &&
        env_1.ENV_NAMES.authentication.jira.apiToken in env) {
        // Jira cloud authentication: username (Email) and token.
        (0, logging_1.logInfo)("Jira username and API token found. Setting up Jira cloud basic auth credentials");
        const credentials = new credentials_1.BasicAuthCredentials(env[env_1.ENV_NAMES.authentication.jira.username], env[env_1.ENV_NAMES.authentication.jira.apiToken]);
        await (0, ping_1.pingJiraInstance)(jiraOptions.url, credentials);
        const jiraClient = new jiraClientCloud_1.JiraClientCloud(jiraOptions.url, credentials);
        if (env_1.ENV_NAMES.authentication.xray.clientId in env &&
            env_1.ENV_NAMES.authentication.xray.clientSecret in env) {
            // Xray cloud authentication: client ID and client secret.
            (0, logging_1.logInfo)("Xray client ID and client secret found. Setting up Xray cloud JWT credentials");
            const xrayCredentials = new credentials_1.JWTCredentials(env[env_1.ENV_NAMES.authentication.xray.clientId], env[env_1.ENV_NAMES.authentication.xray.clientSecret], `${xrayClientCloud_1.XrayClientCloud.URL}/authenticate`);
            await (0, ping_1.pingXrayCloud)(xrayCredentials);
            const xrayClient = new xrayClientCloud_1.XrayClientCloud(xrayCredentials);
            const jiraFieldRepository = new jiraFieldRepository_1.CachingJiraFieldRepository(jiraClient);
            const jiraFieldFetcher = new jiraIssueFetcher_1.JiraIssueFetcherCloud(jiraClient, jiraFieldRepository, xrayClient, jiraOptions);
            return {
                kind: "cloud",
                jiraClient: jiraClient,
                xrayClient: xrayClient,
                jiraRepository: new jiraRepository_1.CachingJiraRepository(jiraFieldRepository, jiraFieldFetcher),
            };
        }
        else {
            throw new Error((0, dedent_1.dedent)(`
                    Failed to configure Xray client: Jira cloud credentials detected, but the provided Xray credentials are not Xray cloud credentials
                    You can find all configurations currently supported at: ${help_1.HELP.plugin.configuration.authentication.root}
                `));
        }
    }
    else if (env_1.ENV_NAMES.authentication.jira.apiToken in env && jiraOptions.url) {
        // Jira server authentication: no username, only token.
        (0, logging_1.logInfo)("Jira PAT found. Setting up Jira server PAT credentials");
        const credentials = new credentials_1.PATCredentials(env[env_1.ENV_NAMES.authentication.jira.apiToken]);
        await (0, ping_1.pingJiraInstance)(jiraOptions.url, credentials);
        const jiraClient = new jiraClientServer_1.JiraClientServer(jiraOptions.url, credentials);
        // Xray server authentication: no username, only token.
        (0, logging_1.logInfo)("Jira PAT found. Setting up Xray server PAT credentials");
        await (0, ping_1.pingXrayServer)(jiraOptions.url, credentials);
        const xrayClient = new xrayClientServer_1.XrayClientServer(jiraOptions.url, credentials);
        const jiraFieldRepository = new jiraFieldRepository_1.CachingJiraFieldRepository(jiraClient);
        const jiraFieldFetcher = new jiraIssueFetcher_1.JiraIssueFetcher(jiraClient, jiraFieldRepository, jiraOptions.fields);
        return {
            kind: "server",
            jiraClient: jiraClient,
            xrayClient: xrayClient,
            jiraRepository: new jiraRepository_1.CachingJiraRepository(jiraFieldRepository, jiraFieldFetcher),
        };
    }
    else if (env_1.ENV_NAMES.authentication.jira.username in env &&
        env_1.ENV_NAMES.authentication.jira.password in env &&
        jiraOptions.url) {
        (0, logging_1.logInfo)("Jira username and password found. Setting up Jira server basic auth credentials");
        const credentials = new credentials_1.BasicAuthCredentials(env[env_1.ENV_NAMES.authentication.jira.username], env[env_1.ENV_NAMES.authentication.jira.password]);
        await (0, ping_1.pingJiraInstance)(jiraOptions.url, credentials);
        const jiraClient = new jiraClientServer_1.JiraClientServer(jiraOptions.url, credentials);
        (0, logging_1.logInfo)("Jira username and password found. Setting up Xray server basic auth credentials");
        await (0, ping_1.pingXrayServer)(jiraOptions.url, credentials);
        const xrayClient = new xrayClientServer_1.XrayClientServer(jiraOptions.url, credentials);
        const jiraFieldRepository = new jiraFieldRepository_1.CachingJiraFieldRepository(jiraClient);
        const jiraFieldFetcher = new jiraIssueFetcher_1.JiraIssueFetcher(jiraClient, jiraFieldRepository, jiraOptions.fields);
        return {
            kind: "server",
            jiraClient: jiraClient,
            xrayClient: xrayClient,
            jiraRepository: new jiraRepository_1.CachingJiraRepository(jiraFieldRepository, jiraFieldFetcher),
        };
    }
    else {
        throw new Error((0, dedent_1.dedent)(`
                Failed to configure Jira client: no viable authentication method was configured
                You can find all configurations currently supported at: ${help_1.HELP.plugin.configuration.authentication.root}
            `));
    }
}
exports.initClients = initClients;
