"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildMultipartFeatures = void 0;
const logging_1 = require("../../logging/logging");
const preprocessing_1 = require("../../preprocessing/preprocessing");
const dedent_1 = require("../../util/dedent");
const errors_1 = require("../../util/errors");
/**
 * Modifies the input Cucumber JSON results by adding test execution issue tags and filtering
 * screenshots, based on the options provided. The function also asserts that every test contained
 * within the results has been appropriately tagged with either Xray cloud or Xray server tags.
 *
 * @param input - the Cucumber JSON results
 * @param options - the options for results modification
 * @returns the modified Cucumber JSON results
 */
function buildMultipartFeatures(input, options) {
    const tests = [];
    input.forEach((result) => {
        const test = {
            ...result,
        };
        if (options?.testExecutionIssueKey) {
            // For feature tags, there's no Cloud/Server distinction for some reason.
            const testExecutionIssueTag = {
                name: `@${options.testExecutionIssueKey}`,
            };
            // Xray uses the first encountered issue tag for deducing the test execution issue.
            if (result.tags) {
                test.tags = [testExecutionIssueTag, ...result.tags];
            }
            else {
                test.tags = [testExecutionIssueTag];
            }
        }
        const elements = [];
        result.elements.forEach((element) => {
            try {
                if (element.type === "scenario") {
                    assertScenarioContainsIssueKey(element, options.projectKey, options.useCloudTags);
                    const modifiedElement = {
                        ...element,
                        steps: getSteps(element, options?.includeScreenshots),
                    };
                    elements.push(modifiedElement);
                }
            }
            catch (error) {
                (0, logging_1.logWarning)((0, dedent_1.dedent)(`
                        Skipping result upload for ${element.type}: ${element.name}

                        ${(0, errors_1.errorMessage)(error)}
                    `));
            }
        });
        if (elements.length > 0) {
            test.elements = elements;
            tests.push(test);
        }
    });
    return tests;
}
exports.buildMultipartFeatures = buildMultipartFeatures;
function assertScenarioContainsIssueKey(element, projectKey, useCloudTags) {
    const issueKeys = [];
    if (element.tags) {
        for (const tag of element.tags) {
            const matches = tag.name.match((0, preprocessing_1.getScenarioTagRegex)(projectKey, useCloudTags));
            if (!matches) {
                continue;
            }
            else if (matches.length === 2) {
                issueKeys.push(matches[1]);
            }
        }
        if (issueKeys.length > 1) {
            throw (0, errors_1.multipleTestKeysInCucumberScenarioError)({
                name: element.name,
                keyword: element.keyword,
            }, element.tags, issueKeys, useCloudTags);
        }
    }
    if (issueKeys.length === 0) {
        throw (0, errors_1.missingTestKeyInCucumberScenarioError)(element, projectKey, useCloudTags);
    }
}
function getSteps(element, includeScreenshots) {
    const steps = [];
    element.steps.forEach((step) => {
        steps.push({
            ...step,
            embeddings: includeScreenshots ? step.embeddings : [],
        });
    });
    return steps;
}
