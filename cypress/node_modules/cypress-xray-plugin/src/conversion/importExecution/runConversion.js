"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTestRunData_V13 = exports.getTestRunData_V12 = void 0;
const preprocessing_1 = require("../../preprocessing/preprocessing");
const statusConversion_1 = require("./statusConversion");
/**
 * Converts a Cypress v12 (or before) run result into several {@link ITestRunData} objects.
 *
 * The function returns an array of promises because the conversion of the test results contained
 * within the run can fail for individual tests. This makes sure that a single failing conversion
 * does not affect or cancel the conversion of the other test results.
 *
 * To retrieve the results, you should use the following approach:
 *
 * ```ts
 *   const testData = await Promise.allSettled(getTestRunData_V12(runResult));
 *   testData.forEach((promise) => {
 *     if (promise.status === "fulfilled") {
 *       // use test data
 *     } else {
 *       // handle failed test conversion
 *     }
 *   });
 * ```
 *
 * @param runResult - the run result
 * @returns an array of test data promises
 */
function getTestRunData_V12(runResult) {
    const testRuns = [];
    runResult.tests.forEach((test) => {
        testRuns.push(new Promise((resolve) => {
            resolve({
                duration: test.attempts[test.attempts.length - 1].duration,
                screenshots: test.attempts[test.attempts.length - 1].screenshots.map((screenshot) => {
                    return { filepath: screenshot.path };
                }),
                spec: {
                    filepath: runResult.spec.absolute,
                },
                startedAt: new Date(test.attempts[test.attempts.length - 1].startedAt),
                status: (0, statusConversion_1.toCypressStatus)(test.attempts[test.attempts.length - 1].state),
                title: test.title.join(" "),
            });
        }));
    });
    return testRuns;
}
exports.getTestRunData_V12 = getTestRunData_V12;
/**
 * Converts a Cypress v13 (and above) run result into several {@link ITestRunData | `ITestRunData`}
 * objects. The project key is required for mapping screenshots to test cases.
 *
 * The function returns an array of promises because the conversion of the test results contained
 * within the run can fail for individual tests. This makes sure that a single failing conversion
 * does not affect or cancel the conversion of the other test results.
 *
 * To retrieve the results, you should use the following approach:
 *
 * ```ts
 *   const testData = await Promise.allSettled(getTestRunData_V13(runResult, projectKey));
 *   testData.forEach((promise) => {
 *     if (promise.status === "fulfilled") {
 *       // use test data
 *     } else {
 *       // handle failed test conversion
 *     }
 *   });
 * ```
 *
 * @param runResult - the run result
 * @param projectKey - the project key
 * @returns an array of test data promises
 */
function getTestRunData_V13(runResult, projectKey) {
    const testRuns = [];
    const testStarts = startTimesByTest(runResult);
    const testScreenshots = screenshotsByTest(runResult, projectKey);
    runResult.tests.forEach((test) => {
        const title = test.title.join(" ");
        const screenshots = testScreenshots[title] ?? [];
        testRuns.push(new Promise((resolve) => {
            resolve({
                duration: test.duration,
                screenshots: screenshots.map((screenshot) => {
                    return { filepath: screenshot.path };
                }),
                spec: {
                    filepath: runResult.spec.absolute,
                },
                startedAt: testStarts.get(title) ?? new Date(),
                status: (0, statusConversion_1.toCypressStatus)(test.state),
                title: title,
            });
        }));
    });
    return testRuns;
}
exports.getTestRunData_V13 = getTestRunData_V13;
function startTimesByTest(run) {
    const map = new Map();
    const testStarts = [];
    for (let i = 0; i < run.tests.length; i++) {
        let date;
        if (i === 0) {
            date = new Date(run.stats.startedAt);
        }
        else {
            date = new Date(testStarts[i - 1].getTime() + run.tests[i - 1].duration);
        }
        testStarts.push(date);
        map.set(run.tests[i].title.join(" "), date);
    }
    return map;
}
function screenshotsByTest(run, projectKey) {
    const map = {};
    for (const screenshot of run.screenshots) {
        for (const test of run.tests) {
            const title = test.title.join(" ");
            if (screenshotNameMatchesTestTitle(screenshot, projectKey, test.title)) {
                if (title in map) {
                    map[title].push(screenshot);
                }
                else {
                    map[title] = [screenshot];
                }
            }
        }
    }
    return map;
}
function screenshotNameMatchesTestTitle(screenshot, projectKey, testTitle) {
    try {
        const testTitleKey = (0, preprocessing_1.getNativeTestIssueKey)(testTitle[testTitle.length - 1], projectKey);
        if (testTitleKey && screenshot.path.includes(testTitleKey)) {
            return true;
        }
    }
    catch (error) {
        // Do nothing.
    }
    return false;
}
