"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachingJiraRepository = void 0;
const logging_1 = require("../../logging/logging");
const dedent_1 = require("../../util/dedent");
const errors_1 = require("../../util/errors");
/**
 * A Jira repository which caches retrieved data. Caching means that live issue information is only
 * retrieved for the first request. All subsequent accesses will then return the cached value.
 */
class CachingJiraRepository {
    jiraFieldRepository;
    jiraIssueFetcher;
    summaries = {};
    descriptions = {};
    testTypes = {};
    labels = {};
    /**
     * Construct a new caching Jira repository. It relies on an internal field repository and an
     * issue data fetcher for information retrieval.
     *
     * @param jiraFieldRepository - the Jira field repository
     * @param jiraIssueFetcher - the Jira issue fetcher
     */
    constructor(jiraFieldRepository, jiraIssueFetcher) {
        this.jiraFieldRepository = jiraFieldRepository;
        this.jiraIssueFetcher = jiraIssueFetcher;
    }
    async getFieldId(fieldName) {
        return this.jiraFieldRepository.getFieldId(fieldName);
    }
    async getSummaries(...issueKeys) {
        let result = {};
        try {
            result = await this.mergeRemainingFields(this.summaries, this.jiraIssueFetcher.fetchSummaries, ...issueKeys);
            const missingSummaries = issueKeys.filter((key) => !(key in this.summaries));
            if (missingSummaries.length > 0) {
                throw new Error((0, dedent_1.dedent)(`
                        Make sure these issues exist:

                          ${missingSummaries.join("\n")}
                    `));
            }
        }
        catch (error) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Failed to fetch issue summaries
                    ${(0, errors_1.errorMessage)(error)}
                `));
        }
        return result;
    }
    async getDescriptions(...issueKeys) {
        let result = {};
        try {
            result = await this.mergeRemainingFields(this.descriptions, this.jiraIssueFetcher.fetchDescriptions, ...issueKeys);
            const missingDescriptions = issueKeys.filter((key) => !(key in this.descriptions));
            if (missingDescriptions.length > 0) {
                throw new Error((0, dedent_1.dedent)(`
                        Make sure these issues exist:

                          ${missingDescriptions.join("\n")}
                    `));
            }
        }
        catch (error) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Failed to fetch issue descriptions
                    ${(0, errors_1.errorMessage)(error)}
                `));
        }
        return result;
    }
    async getTestTypes(...issueKeys) {
        let result = {};
        try {
            result = await this.mergeRemainingFields(this.testTypes, this.jiraIssueFetcher.fetchTestTypes, ...issueKeys);
            const missingTestTypes = issueKeys.filter((key) => !(key in this.testTypes));
            if (missingTestTypes.length > 0) {
                throw new Error((0, dedent_1.dedent)(`
                        Make sure these issues exist and are test issues:

                          ${missingTestTypes.join("\n")}
                    `));
            }
        }
        catch (error) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Failed to fetch issue test types
                    ${(0, errors_1.errorMessage)(error)}
                `));
        }
        return result;
    }
    async getLabels(...issueKeys) {
        let result = {};
        try {
            result = await this.mergeRemainingFields(this.labels, this.jiraIssueFetcher.fetchLabels, ...issueKeys);
            const missingLabels = issueKeys.filter((key) => !(key in this.labels));
            if (missingLabels.length > 0) {
                throw new Error((0, dedent_1.dedent)(`
                        Make sure these issues exist:

                          ${missingLabels.join("\n")}
                    `));
            }
        }
        catch (error) {
            (0, logging_1.logError)((0, dedent_1.dedent)(`
                    Failed to fetch issue labels
                    ${(0, errors_1.errorMessage)(error)}
                `));
        }
        return result;
    }
    async mergeRemainingFields(knownFields, fetcher, ...issueKeys) {
        const issuesWithMissingField = issueKeys.filter((key) => !(key in knownFields));
        if (issuesWithMissingField.length > 0) {
            const fetchedFields = await fetcher(...issuesWithMissingField);
            issueKeys.forEach((key) => {
                if (key in fetchedFields) {
                    knownFields[key] = fetchedFields[key];
                }
            });
        }
        const result = {};
        issueKeys.forEach((key) => {
            if (key in knownFields) {
                result[key] = knownFields[key];
            }
        });
        return result;
    }
}
exports.CachingJiraRepository = CachingJiraRepository;
