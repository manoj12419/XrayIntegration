"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JiraIssueFetcherCloud = exports.JiraIssueFetcher = exports.SupportedFields = void 0;
const dedent_1 = require("../../../util/dedent");
const errors_1 = require("../../../util/errors");
const extraction_1 = require("../../../util/extraction");
var SupportedFields;
(function (SupportedFields) {
    SupportedFields["DESCRIPTION"] = "description";
    SupportedFields["SUMMARY"] = "summary";
    SupportedFields["LABELS"] = "labels";
    SupportedFields["TEST_ENVIRONMENTS"] = "test environments";
    SupportedFields["TEST_PLAN"] = "test plan";
    SupportedFields["TEST_TYPE"] = "test type";
})(SupportedFields || (exports.SupportedFields = SupportedFields = {}));
/**
 * A generic Jira issue data fetcher which fetches issue data for every call, i.e. does not perform
 * any caching.
 */
class JiraIssueFetcher {
    jiraClient;
    jiraFieldRepository;
    fieldIds;
    /**
     * Constructs a new Jira issue fetcher. The Jira client is necessary for accessing Jira. The
     * field repository is required because issue data can only be retrieved through Jira fields,
     * which might have custom field IDs. An optional mapping of known field IDs can be provided,
     * which will then be used instead of accessing the field repository.
     *
     * @param jiraClient - the Jira client
     * @param jiraFieldRepository - the Jira field repository
     * @param fieldIds - an optional mapping of known field IDs
     */
    constructor(jiraClient, jiraFieldRepository, fieldIds) {
        this.jiraClient = jiraClient;
        this.jiraFieldRepository = jiraFieldRepository;
        this.fieldIds = fieldIds;
    }
    async fetchSummaries(...issueKeys) {
        let summaryId = this.fieldIds?.summary;
        if (!summaryId) {
            summaryId = await this.jiraFieldRepository.getFieldId(SupportedFields.SUMMARY);
        }
        // Field property example:
        // summary: "Bug 12345"
        const fields = await this.fetchFieldData(summaryId, (issue, fieldId) => {
            return (0, extraction_1.extractString)(issue.fields, fieldId);
        }, ...issueKeys);
        return fields;
    }
    async fetchDescriptions(...issueKeys) {
        let descriptionId = this.fieldIds?.description;
        if (!descriptionId) {
            descriptionId = await this.jiraFieldRepository.getFieldId(SupportedFields.DESCRIPTION);
        }
        // Field property example:
        // description: "This is a description"
        const fields = await this.fetchFieldData(descriptionId, (issue, fieldId) => {
            return (0, extraction_1.extractString)(issue.fields, fieldId);
        }, ...issueKeys);
        return fields;
    }
    async fetchLabels(...issueKeys) {
        let labelsId = this.fieldIds?.labels;
        if (!labelsId) {
            labelsId = await this.jiraFieldRepository.getFieldId(SupportedFields.LABELS);
        }
        // Field property example:
        // labels: ["regression", "quality"]
        const fields = await this.fetchFieldData(labelsId, (issue, fieldId) => {
            return (0, extraction_1.extractArrayOfStrings)(issue.fields, fieldId);
        }, ...issueKeys);
        return fields;
    }
    async fetchTestTypes(...issueKeys) {
        let testTypeId = this.fieldIds?.testType;
        if (!testTypeId) {
            testTypeId = await this.jiraFieldRepository.getFieldId(SupportedFields.TEST_TYPE);
        }
        // Field property example:
        // customfield_12100: {
        //   value: "Cucumber",
        //   id: "12702",
        //   disabled: false
        // }
        const fields = await this.fetchFieldData(testTypeId, (issue, fieldId) => {
            return (0, extraction_1.extractNestedString)(issue.fields, [fieldId, "value"]);
        }, ...issueKeys);
        return fields;
    }
    async fetchFieldData(fieldId, extractor, ...issueKeys) {
        const results = {};
        const issues = await this.jiraClient.search({
            jql: `issue in (${issueKeys.join(",")})`,
            fields: [fieldId],
        });
        if (issues) {
            const issuesWithUnparseableField = [];
            for (const issue of issues) {
                try {
                    if (issue.key) {
                        results[issue.key] = await extractor(issue, fieldId);
                    }
                    else {
                        issuesWithUnparseableField.push(`Unknown: ${JSON.stringify(issue)}`);
                    }
                }
                catch (error) {
                    issuesWithUnparseableField.push(`${issue.key ?? "Unknown issue"}: ${(0, errors_1.errorMessage)(error)}`);
                }
            }
            if (issuesWithUnparseableField.length > 0) {
                issuesWithUnparseableField.sort();
                throw new Error((0, dedent_1.dedent)(`
                        Failed to parse Jira field with ID: ${fieldId}
                        Make sure the correct field is present on the following issues:

                          ${issuesWithUnparseableField.join("\n")}
                    `));
            }
        }
        return results;
    }
}
exports.JiraIssueFetcher = JiraIssueFetcher;
class JiraIssueFetcherCloud extends JiraIssueFetcher {
    xrayClient;
    jiraOptions;
    constructor(jiraClient, jiraFieldRepository, xrayClient, jiraOptions) {
        super(jiraClient, jiraFieldRepository, jiraOptions.fields);
        this.xrayClient = xrayClient;
        this.jiraOptions = jiraOptions;
    }
    async fetchTestTypes(...issueKeys) {
        return await this.xrayClient.getTestTypes(this.jiraOptions.projectKey, ...issueKeys);
    }
}
exports.JiraIssueFetcherCloud = JiraIssueFetcherCloud;
