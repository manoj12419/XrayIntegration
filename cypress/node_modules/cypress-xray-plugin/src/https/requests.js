"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Requests = void 0;
const axios_1 = __importStar(require("axios"));
const fs_1 = require("fs");
const https_1 = require("https");
const logging_1 = require("../logging/logging");
const files_1 = require("../util/files");
class Requests {
    static AGENT = undefined;
    static AXIOS = undefined;
    static options = undefined;
    static init(options) {
        Requests.options = options;
    }
    static agent() {
        if (!Requests.AGENT) {
            Requests.AGENT = new https_1.Agent({
                ca: Requests.readCertificate(Requests.options?.openSSL?.rootCAPath),
                secureOptions: Requests.options?.openSSL?.secureOptions,
            });
        }
        return Requests.AGENT;
    }
    static axios() {
        if (!Requests.options) {
            throw new Error("Requests module has not been initialized");
        }
        if (!Requests.AXIOS) {
            Requests.AXIOS = axios_1.default;
            if (Requests.options.debug) {
                Requests.AXIOS.interceptors.request.use((request) => {
                    const method = request.method?.toUpperCase();
                    const url = request.url;
                    const timestamp = Date.now();
                    const filename = (0, files_1.normalizedFilename)(`${timestamp}_${method}_${url}_request.json`);
                    const resolvedFilename = (0, logging_1.writeFile)({
                        url: url,
                        headers: request.headers,
                        params: request.params,
                        body: request.data,
                    }, filename);
                    (0, logging_1.logDebug)(`Request:  ${resolvedFilename}`);
                    return request;
                }, (error) => {
                    const timestamp = Date.now();
                    let filename;
                    let data;
                    if ((0, axios_1.isAxiosError)(error)) {
                        const method = error.config?.method?.toUpperCase();
                        const url = error.config?.url;
                        filename = (0, files_1.normalizedFilename)(`${timestamp}_${method}_${url}_request.json`);
                        data = error.toJSON();
                    }
                    else {
                        filename = (0, files_1.normalizedFilename)(`${timestamp}_request.json`);
                        data = error;
                    }
                    const resolvedFilename = (0, logging_1.writeFile)(data, filename);
                    (0, logging_1.logDebug)(`Request:  ${resolvedFilename}`);
                    return Promise.reject(error);
                });
                Requests.AXIOS.interceptors.response.use((response) => {
                    const method = response.request.method.toUpperCase();
                    const url = response.config.url;
                    const timestamp = Date.now();
                    const filename = (0, files_1.normalizedFilename)(`${timestamp}_${method}_${url}_response.json`);
                    const resolvedFilename = (0, logging_1.writeFile)({
                        data: response.data,
                        headers: response.headers,
                        status: response.status,
                        statusText: response.statusText,
                    }, filename);
                    (0, logging_1.logDebug)(`Response: ${resolvedFilename}`);
                    return response;
                }, (error) => {
                    const timestamp = Date.now();
                    let filename;
                    let data;
                    if ((0, axios_1.isAxiosError)(error)) {
                        const method = error.config?.method?.toUpperCase();
                        const url = error.config?.url;
                        filename = (0, files_1.normalizedFilename)(`${timestamp}_${method}_${url}_response.json`);
                        data = error.toJSON();
                    }
                    else {
                        filename = (0, files_1.normalizedFilename)(`${timestamp}_response.json`);
                        data = error;
                    }
                    const resolvedFilename = (0, logging_1.writeFile)(data, filename);
                    (0, logging_1.logDebug)(`Response: ${resolvedFilename}`);
                    return Promise.reject(error);
                });
            }
        }
        return Requests.AXIOS;
    }
    static readCertificate(path) {
        if (!path) {
            return undefined;
        }
        return (0, fs_1.readFileSync)(path);
    }
    static async get(url, config) {
        return Requests.axios().get(url, {
            ...config,
            httpsAgent: Requests.agent(),
        });
    }
    static async post(url, data, config) {
        return Requests.axios().post(url, data, {
            ...config,
            httpsAgent: Requests.agent(),
        });
    }
    static async put(url, data, config) {
        return Requests.axios().put(url, data, {
            ...config,
            httpsAgent: Requests.agent(),
        });
    }
}
exports.Requests = Requests;
