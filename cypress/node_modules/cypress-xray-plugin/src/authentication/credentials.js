"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWTCredentials = exports.PATCredentials = exports.BasicAuthCredentials = void 0;
const requests_1 = require("../https/requests");
const logging_1 = require("../logging/logging");
const base64_1 = require("../util/base64");
const dedent_1 = require("../util/dedent");
const errors_1 = require("../util/errors");
const time_1 = require("../util/time");
/**
 * A basic authorization credentials class, storing base64 encoded credentials of usernames and
 * passwords.
 */
class BasicAuthCredentials {
    encodedCredentials;
    /**
     * Constructs new basic authorization credentials.
     *
     * @param username - the username
     * @param password - the password
     */
    constructor(username, password) {
        // See: https://developer.atlassian.com/server/jira/platform/basic-authentication/#construct-the-authorization-header
        this.encodedCredentials = (0, base64_1.encode)(`${username}:${password}`);
    }
    async getAuthorizationHeader() {
        return {
            Authorization: `Basic ${this.encodedCredentials}`,
        };
    }
}
exports.BasicAuthCredentials = BasicAuthCredentials;
/**
 * A personal access token (_PAT_) credentials class, storing a secret token to use during HTTP
 * authorization.
 */
class PATCredentials {
    token;
    /**
     * Constructs new PAT credentials from the provided token.
     *
     * @param token - the token
     */
    constructor(token) {
        this.token = token;
    }
    async getAuthorizationHeader() {
        return {
            Authorization: `Bearer ${this.token}`,
        };
    }
}
exports.PATCredentials = PATCredentials;
/**
 * A JWT credentials class, storing a JWT token to use during HTTP authorization. The class is
 * designed to retrieve fresh JWT tokens from an authentication URL/endpoint. Once retrieved, the
 * token will be stored and reused whenever necessary.
 */
class JWTCredentials {
    clientId;
    clientSecret;
    authenticationUrl;
    token;
    /**
     * Constructs new JWT credentials. The client ID and client secret will be used to retrieve a
     * JWT token from the authentication URL on demand.
     *
     * @param clientId - the client ID
     * @param clientSecret - the client secret
     * @param authenticationUrl - the authentication URL/token endpoint
     */
    constructor(clientId, clientSecret, authenticationUrl) {
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.authenticationUrl = authenticationUrl;
        this.token = undefined;
    }
    /**
     * Return the URL to authenticate to.
     *
     * @returns the URL
     */
    getAuthenticationUrl() {
        return this.authenticationUrl;
    }
    async getToken() {
        if (!this.token) {
            try {
                const progressInterval = (0, time_1.startInterval)((totalTime) => {
                    (0, logging_1.logInfo)(`Waiting for ${this.authenticationUrl} to respond... (${totalTime / 1000} seconds)`);
                });
                try {
                    (0, logging_1.logInfo)(`Authenticating to: ${this.authenticationUrl}...`);
                    const tokenResponse = await requests_1.Requests.post(this.authenticationUrl, {
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                    });
                    // A JWT token is expected: https://stackoverflow.com/a/74325712
                    const jwtRegex = /^[A-Za-z0-9_-]{2,}(?:\.[A-Za-z0-9_-]{2,}){2}$/;
                    if (jwtRegex.test(tokenResponse.data)) {
                        (0, logging_1.logDebug)("Authentication successful.");
                        this.token = tokenResponse.data;
                        return tokenResponse.data;
                    }
                    else {
                        throw new Error("Expected to receive a JWT token, but did not");
                    }
                }
                finally {
                    clearInterval(progressInterval);
                }
            }
            catch (error) {
                const message = (0, errors_1.errorMessage)(error);
                (0, logging_1.logError)((0, dedent_1.dedent)(`
                        Failed to authenticate to: ${this.authenticationUrl}

                        ${message}
                    `));
                (0, logging_1.writeErrorFile)(error, "authentication");
                throw new errors_1.LoggedError("Authentication failed");
            }
        }
        return this.token;
    }
    async getAuthorizationHeader() {
        return {
            Authorization: `Bearer ${await this.getToken()}`,
        };
    }
}
exports.JWTCredentials = JWTCredentials;
