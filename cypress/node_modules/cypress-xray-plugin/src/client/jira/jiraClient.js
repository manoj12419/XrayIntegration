"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JiraClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = __importDefault(require("fs"));
const requests_1 = require("../../https/requests");
const logging_1 = require("../../logging/logging");
const dedent_1 = require("../../util/dedent");
const client_1 = require("../client");
/**
 * A Jira client class for communicating with Jira instances.
 */
class JiraClient extends client_1.Client {
    /**
     * Construct a new Jira client using the provided credentials.
     *
     * @param apiBaseUrl - the Jira base endpoint
     * @param credentials - the credentials to use during authentication
     */
    constructor(apiBaseUrl, credentials) {
        super(apiBaseUrl, credentials);
    }
    async addAttachment(issueIdOrKey, ...files) {
        if (files.length === 0) {
            (0, logging_1.logWarning)(`No files provided to attach to issue ${issueIdOrKey}. Skipping attaching.`);
            return [];
        }
        const form = new form_data_1.default();
        let filesIncluded = 0;
        files.forEach((file) => {
            if (!fs_1.default.existsSync(file)) {
                (0, logging_1.logWarning)("File does not exist:", file);
                return;
            }
            filesIncluded++;
            const fileContent = fs_1.default.createReadStream(file);
            form.append("file", fileContent);
        });
        if (filesIncluded === 0) {
            (0, logging_1.logWarning)("All files do not exist. Skipping attaching.");
            return [];
        }
        try {
            return await this.credentials
                .getAuthorizationHeader()
                .then(async (header) => {
                (0, logging_1.logDebug)("Attaching files:", ...files);
                const progressInterval = this.startResponseInterval(this.apiBaseUrl);
                try {
                    const response = await requests_1.Requests.post(this.getUrlAddAttachment(issueIdOrKey), form, {
                        headers: {
                            ...header,
                            ...form.getHeaders(),
                            "X-Atlassian-Token": "no-check",
                        },
                    });
                    (0, logging_1.logDebug)((0, dedent_1.dedent)(`
                                Successfully attached files to issue: ${issueIdOrKey}
                                  ${response.data
                        .map((attachment) => attachment.filename)
                        .join("\n")}
                            `));
                    return response.data;
                }
                finally {
                    clearInterval(progressInterval);
                }
            });
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to attach files: ${error}`);
            (0, logging_1.writeErrorFile)(error, "addAttachmentError");
        }
    }
    async getIssueTypes() {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            (0, logging_1.logDebug)("Getting issue types...");
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const response = await requests_1.Requests.get(this.getUrlGetIssueTypes(), {
                    headers: {
                        ...authorizationHeader,
                    },
                });
                (0, logging_1.logDebug)(`Successfully retrieved data for ${response.data.length} issue types.`);
                (0, logging_1.logDebug)((0, dedent_1.dedent)(`
                        Received data for issue types:
                        ${response.data
                    .map((issueType) => `${issueType.name} (id: ${issueType.id})`)
                    .join("\n")}
                    `));
                return response.data;
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to get issue types: ${error}`);
            (0, logging_1.writeErrorFile)(error, "getIssueTypesError");
        }
    }
    async getFields() {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            (0, logging_1.logDebug)("Getting fields...");
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const response = await requests_1.Requests.get(this.getUrlGetFields(), {
                    headers: {
                        ...authorizationHeader,
                    },
                });
                (0, logging_1.logDebug)(`Successfully retrieved data for ${response.data.length} fields`);
                (0, logging_1.logDebug)((0, dedent_1.dedent)(`
                        Received data for fields:
                        ${response.data
                    .map((field) => `${field.name} (id: ${field.id})`)
                    .join("\n")}
                    `));
                return response.data;
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to get fields: ${error}`);
            (0, logging_1.writeErrorFile)(error, "getFieldsError");
        }
    }
    async search(request) {
        try {
            return await this.credentials
                .getAuthorizationHeader()
                .then(async (header) => {
                (0, logging_1.logDebug)("Searching issues...");
                const progressInterval = this.startResponseInterval(this.apiBaseUrl);
                try {
                    let total = 0;
                    let startAt = request.startAt ?? 0;
                    const results = [];
                    do {
                        const paginatedRequest = {
                            ...request,
                            startAt: startAt,
                        };
                        const response = await requests_1.Requests.post(this.getUrlPostSearch(), paginatedRequest, {
                            headers: {
                                ...header,
                            },
                        });
                        total = response.data.total ?? total;
                        if (response.data.issues) {
                            results.push(...response.data.issues);
                            // Explicit check because it could also be 0.
                            if (typeof response.data.startAt === "number") {
                                startAt = response.data.startAt + response.data.issues.length;
                            }
                        }
                    } while (startAt && startAt < total);
                    (0, logging_1.logDebug)(`Found ${total} issues`);
                    return results;
                }
                finally {
                    clearInterval(progressInterval);
                }
            });
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to search issues: ${error}`);
            (0, logging_1.writeErrorFile)(error, "searchError");
        }
    }
    async editIssue(issueIdOrKey, issueUpdateData) {
        try {
            await this.credentials.getAuthorizationHeader().then(async (header) => {
                (0, logging_1.logDebug)("Editing issue...");
                const progressInterval = this.startResponseInterval(this.apiBaseUrl);
                try {
                    await requests_1.Requests.put(this.getUrlEditIssue(issueIdOrKey), issueUpdateData, {
                        headers: {
                            ...header,
                        },
                    });
                    (0, logging_1.logDebug)(`Successfully edited issue: ${issueIdOrKey}`);
                }
                finally {
                    clearInterval(progressInterval);
                }
            });
            return issueIdOrKey;
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to edit issue: ${error}`);
            (0, logging_1.writeErrorFile)(error, "editIssue");
        }
    }
}
exports.JiraClient = JiraClient;
