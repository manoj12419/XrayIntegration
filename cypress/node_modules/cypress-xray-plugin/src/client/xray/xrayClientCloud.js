"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrayClientCloud = void 0;
const form_data_1 = __importDefault(require("form-data"));
const requests_1 = require("../../https/requests");
const logging_1 = require("../../logging/logging");
const dedent_1 = require("../../util/dedent");
const xrayClient_1 = require("./xrayClient");
class XrayClientCloud extends xrayClient_1.XrayClient {
    /**
     * The URLs of Xray's Cloud API.
     * Note: API v1 would also work, but let's stick to the more recent one.
     */
    static URL = "https://xray.cloud.getxray.app/api/v2";
    static URL_GRAPHQL = `${XrayClientCloud.URL}/graphql`;
    static GRAPHQL_LIMITS = {
        /**
         * @see https://xray.cloud.getxray.app/doc/graphql/gettests.doc.html
         */
        getTests: 100,
    };
    /**
     * Construct a new Xray cloud client using the provided credentials.
     *
     * @param credentials - the credentials to use during authentication
     */
    constructor(credentials) {
        super(XrayClientCloud.URL, credentials);
    }
    getUrlImportExecution() {
        return `${this.apiBaseUrl}/import/execution`;
    }
    handleResponseImportExecution(response) {
        return response.key;
    }
    getUrlExportCucumber(issueKeys, filter) {
        const query = [];
        if (issueKeys) {
            query.push(`keys=${issueKeys.join(";")}`);
        }
        if (filter) {
            query.push(`filter=${filter}`);
        }
        if (query.length === 0) {
            throw new Error("One of issueKeys or filter must be provided to export feature files");
        }
        return `${this.apiBaseUrl}/export/cucumber?${query.join("&")}`;
    }
    getUrlImportFeature(projectKey, projectId) {
        const query = [];
        if (projectKey) {
            query.push(`projectKey=${projectKey}`);
        }
        if (projectId) {
            query.push(`projectId=${projectId}`);
        }
        return `${this.apiBaseUrl}/import/feature?${query.join("&")}`;
    }
    handleResponseImportFeature(response) {
        if (response.errors.length > 0) {
            (0, logging_1.logError)("Encountered some errors during import:", ...response.errors);
        }
        if (response.updatedOrCreatedTests.length > 0) {
            (0, logging_1.logDebug)("Successfully updated or created test issues:", response.updatedOrCreatedTests.map((issue) => issue.key).join(", "));
        }
        if (response.updatedOrCreatedPreconditions.length > 0) {
            (0, logging_1.logDebug)("Successfully updated or created precondition issues:", response.updatedOrCreatedPreconditions
                .map((issue) => issue.key)
                .join(", "));
        }
    }
    async getTestTypes(projectKey, ...issueKeys) {
        try {
            if (!issueKeys || issueKeys.length === 0) {
                (0, logging_1.logWarning)("No issue keys provided. Skipping test type retrieval");
                return {};
            }
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            (0, logging_1.logDebug)("Retrieving test types...");
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const types = {};
                let total = 0;
                let start = 0;
                const jql = `project = '${projectKey}' AND issue in (${issueKeys.join(",")})`;
                const query = (0, dedent_1.dedent)(`
                    query($jql: String, $start: Int!, $limit: Int!) {
                        getTests(jql: $jql, start: $start, limit: $limit) {
                            total
                            start
                            results {
                                testType {
                                    name
                                    kind
                                }
                                jira(fields: ["key"])
                            }
                        }
                    }
                `);
                do {
                    const paginatedRequest = {
                        query: query,
                        variables: {
                            jql: jql,
                            start: start,
                            limit: XrayClientCloud.GRAPHQL_LIMITS.getTests,
                        },
                    };
                    const response = (await requests_1.Requests.post(XrayClientCloud.URL_GRAPHQL, paginatedRequest, {
                        headers: {
                            ...authorizationHeader,
                        },
                    })).data;
                    total = response.data.getTests.total ?? total;
                    if (response.data.getTests.results) {
                        if (typeof response.data.getTests.start === "number") {
                            start =
                                response.data.getTests.start +
                                    response.data.getTests.results.length;
                        }
                        for (const test of response.data.getTests.results) {
                            if (test?.jira.key && test.testType?.name) {
                                types[test.jira.key] = test.testType.name;
                            }
                        }
                    }
                } while (start && start < total);
                const missingTypes = [];
                for (const issueKey of issueKeys) {
                    if (!(issueKey in types)) {
                        missingTypes.push(issueKey);
                    }
                }
                if (missingTypes.length > 0) {
                    throw new Error((0, dedent_1.dedent)(`
                            Failed to retrieve test types for issues:

                              ${missingTypes.join("\n")}

                            Make sure these issues exist and are actually test issues
                        `));
                }
                (0, logging_1.logDebug)(`Successfully retrieved test types for ${issueKeys.length} issues`);
                return types;
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to get test types: ${error}`);
            (0, logging_1.writeErrorFile)(error, "getTestTypes");
        }
        return {};
    }
    async prepareRequestImportExecutionCucumberMultipart(cucumberJson, cucumberInfo) {
        const formData = new form_data_1.default();
        const resultString = JSON.stringify(cucumberJson);
        const infoString = JSON.stringify(cucumberInfo);
        formData.append("results", resultString, {
            filename: "results.json",
        });
        formData.append("info", infoString, {
            filename: "info.json",
        });
        const authorizationHeader = await this.credentials.getAuthorizationHeader();
        return {
            url: `${this.apiBaseUrl}/import/execution/cucumber/multipart`,
            data: formData,
            config: {
                headers: {
                    ...authorizationHeader,
                    ...formData.getHeaders(),
                },
            },
        };
    }
    handleResponseImportExecutionCucumberMultipart(response) {
        return response.key;
    }
}
exports.XrayClientCloud = XrayClientCloud;
