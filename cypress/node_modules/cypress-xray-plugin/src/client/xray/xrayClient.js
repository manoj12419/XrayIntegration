"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrayClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = __importDefault(require("fs"));
const requests_1 = require("../../https/requests");
const logging_1 = require("../../logging/logging");
const client_1 = require("../client");
/**
 * An abstract Xray client class for communicating with Xray instances.
 */
class XrayClient extends client_1.Client {
    /**
     * Construct a new client using the provided credentials.
     *
     * @param apiBaseUrl - the base URL for all HTTP requests
     * @param credentials - the credentials to use during authentication
     */
    constructor(apiBaseUrl, credentials) {
        super(apiBaseUrl, credentials);
    }
    async importExecution(execution) {
        try {
            if (!execution.tests || execution.tests.length === 0) {
                (0, logging_1.logWarning)("No native Cypress tests were executed. Skipping native upload.");
                return null;
            }
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            (0, logging_1.logDebug)("Importing execution...");
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const response = await requests_1.Requests.post(this.getUrlImportExecution(), execution, {
                    headers: {
                        ...authorizationHeader,
                    },
                });
                const key = this.handleResponseImportExecution(response.data);
                (0, logging_1.logDebug)(`Successfully uploaded test execution results to ${key}.`);
                return key;
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to import execution: ${error}`);
            (0, logging_1.writeErrorFile)(error, "importExecutionError");
        }
    }
    async exportCucumber(keys, filter) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            (0, logging_1.logDebug)("Exporting Cucumber tests...");
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const response = await requests_1.Requests.get(this.getUrlExportCucumber(keys, filter), {
                    headers: {
                        ...authorizationHeader,
                    },
                });
                // Extract filename from response.
                const contentDisposition = response.headers["Content-Disposition"];
                const filenameStart = contentDisposition.indexOf('"');
                const filenameEnd = contentDisposition.lastIndexOf('"');
                const filename = contentDisposition.substring(filenameStart, filenameEnd);
                fs_1.default.writeFile(filename, response.data, (error) => {
                    throw new Error(`Failed to export cucumber feature files: "${error}"`);
                });
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to export Cucumber tests: ${error}`);
            (0, logging_1.writeErrorFile)(error, "exportCucumberError");
        }
        throw new Error("Method not implemented.");
    }
    async importFeature(file, projectKey, projectId, source) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            (0, logging_1.logDebug)("Importing Cucumber features...");
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const fileContent = fs_1.default.createReadStream(file);
                const form = new form_data_1.default();
                form.append("file", fileContent);
                const response = await requests_1.Requests.post(this.getUrlImportFeature(projectKey, projectId, source), form, {
                    headers: {
                        ...authorizationHeader,
                        ...form.getHeaders(),
                    },
                });
                this.handleResponseImportFeature(response.data);
                return true;
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to import cucumber features: ${error}`);
            (0, logging_1.writeErrorFile)(error, "importFeatureError");
        }
        return false;
    }
    async importExecutionCucumberMultipart(cucumberJson, cucumberInfo) {
        try {
            if (cucumberJson.length === 0) {
                (0, logging_1.logWarning)("No Cucumber tests were executed. Skipping Cucumber upload.");
                return null;
            }
            (0, logging_1.logDebug)("Importing execution (Cucumber)...");
            const request = await this.prepareRequestImportExecutionCucumberMultipart(cucumberJson, cucumberInfo);
            const progressInterval = this.startResponseInterval(this.apiBaseUrl);
            try {
                const response = await requests_1.Requests.post(request.url, request.data, request.config);
                const key = this.handleResponseImportExecutionCucumberMultipart(response.data);
                (0, logging_1.logDebug)(`Successfully uploaded Cucumber test execution results to ${key}.`);
                return key;
            }
            finally {
                clearInterval(progressInterval);
            }
        }
        catch (error) {
            (0, logging_1.logError)(`Failed to import Cucumber execution: ${error}`);
            (0, logging_1.writeErrorFile)(error, "importExecutionCucumberMultipartError");
        }
    }
}
exports.XrayClient = XrayClient;
