"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrayClientServer = void 0;
const form_data_1 = __importDefault(require("form-data"));
const logging_1 = require("../../logging/logging");
const xrayClient_1 = require("./xrayClient");
class XrayClientServer extends xrayClient_1.XrayClient {
    /**
     * Construct a new Xray Server client using the provided credentials.
     *
     * @param apiBaseUrl - the base URL for all HTTP requests
     * @param credentials - the credentials to use during authentication
     */
    constructor(apiBaseUrl, credentials) {
        super(apiBaseUrl, credentials);
    }
    getUrlImportExecution() {
        return `${this.apiBaseUrl}/rest/raven/latest/import/execution`;
    }
    handleResponseImportExecution(response) {
        return response.testExecIssue.key;
    }
    getUrlExportCucumber(issueKeys, filter) {
        const query = [];
        if (issueKeys) {
            query.push(`keys=${issueKeys.join(";")}`);
        }
        if (filter) {
            query.push(`filter=${filter}`);
        }
        if (query.length === 0) {
            throw new Error("One of issueKeys or filter must be provided to export feature files");
        }
        // Always zip feature files, even single ones.
        query.push("fz=true");
        return `${this.apiBaseUrl}/rest/raven/latest/export/test?${query.join("&")}`;
    }
    getUrlImportFeature(projectKey) {
        return `${this.apiBaseUrl}/rest/raven/latest/import/feature?projectKey=${projectKey}`;
    }
    handleResponseImportFeature(response) {
        // Happens when scenarios cause errors in Xray, e.g. typos in keywords ('Scenariot').
        if (typeof response === "object" && "message" in response) {
            if (response.message) {
                (0, logging_1.logError)("Encountered an error during import:", response.message);
            }
            if (response.testIssues && response.testIssues.length > 0) {
                (0, logging_1.logDebug)("Successfully updated or created test issues:", response.testIssues.map((issue) => issue.key).join(", "));
            }
            if (response.preconditionIssues && response.preconditionIssues.length > 0) {
                (0, logging_1.logDebug)("Successfully updated or created precondition issues:", response.preconditionIssues.map((issue) => issue.key).join(", "));
            }
        }
        else if (Array.isArray(response)) {
            (0, logging_1.logDebug)("Successfully updated or created issues:", response.map((issue) => issue.key).join(", "));
        }
    }
    async prepareRequestImportExecutionCucumberMultipart(cucumberJson, cucumberInfo) {
        const formData = new form_data_1.default();
        const resultString = JSON.stringify(cucumberJson);
        const infoString = JSON.stringify(cucumberInfo);
        formData.append("result", resultString, {
            filename: "results.json",
        });
        formData.append("info", infoString, {
            filename: "info.json",
        });
        const authorizationHeader = await this.credentials.getAuthorizationHeader();
        return {
            url: `${this.apiBaseUrl}/rest/raven/latest/import/execution/cucumber/multipart`,
            data: formData,
            config: {
                headers: {
                    ...authorizationHeader,
                    ...formData.getHeaders(),
                },
            },
        };
    }
    handleResponseImportExecutionCucumberMultipart(response) {
        return response.testExecIssue.key;
    }
}
exports.XrayClientServer = XrayClientServer;
